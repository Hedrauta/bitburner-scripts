/** @param {NS} ns **/
export async function main(ns) {
  const script_servers = [
    {
      name: "32TB_1",
      active_threads: 0, // init
      free_threads: 0, // init
      process_list: []
    },
    {
      name: "32TB_2",
      active_threads: 0, // init
      free_threads: 0, // init
      process_list: []
    },
    {
      name: "32TB_3",
      active_threads: 0, // init
      free_threads: 0, // init
      process_list: []
    },
    {
      name: "32TB_4",
      active_threads: 0, // init
      free_threads: 0, // init
      process_list: []
    }
  ];
  // update ram & pos_threads
  const script_size = 1.75;
  for (var srv_key in script_servers) {
    const ramsrv = script_servers[srv_key];
    ramsrv.max_ram = ns.getServerMaxRam(ramsrv.name);
    ramsrv.pos_threads = Math.floor(ramsrv.max_ram / script_size)
  };

  // copy grow/weaken-scripts on the working servers
  await ns.wget("https://github.com/Hedrauta/bitburner-scripts/raw/master/H3draut3r%236722/weaken_grow_ctrl_scripts/grow_server.script", "/ctrl/grow_server.script", ns.gethostname);
  await ns.wget("https://github.com/Hedrauta/bitburner-scripts/raw/master/H3draut3r%236722/weaken_grow_ctrl_scripts/weaken_server.script", "ctrl/weaken_server.script", ns.gethostname);
  for (var copy_key in script_servers) {
    const srvscp = script_servers[copy_key];
    await ns.scp(["/ctrl/grow_server.script", "/ctrl/weaken_server.script"], ns.getHostname(), srvscp.name)
  }
  // done copy ≡(▔﹏▔)≡


  // initialise servers which are not owned or "home" (credits to Pwnzerfaust, Azirale & Kozd)

  // start fetching all server in range of home filter for owned ones, and do depth-scanning
  const ignoredServers = ["home", "CSEC"]; // do not have money, will never generate
  const homeServers = ns.scan("home");
  const myServers = ns.getPurchasedServers();
  const D0Servers = homeServers.filter(hmuf => !myServers.includes(hmuf) && hmuf != ignoredServers);
  const targetServer = D0Servers; // list of "targetable" Servers
  const D1Servers = D0Servers.flatMap(d1uf => ns.scan(d1uf))
    .filter(d1f => !targetServer.includes(d1f) && d1f != ignoredServers);
  D1Servers.map(d1fs => targetServer.push(d1fs));
  const D2Servers = D1Servers.flatMap(d2uf => ns.scan(d2uf))
    .filter(d2f => !targetServer.includes(d2f) && d2f != ignoredServers);
  D2Servers.map(d2fs => targetServer.push(d2fs));



  async function update_servers() {
    for (var srv of script_servers) {
      srv.active_threads = 0;
      srv.process_list = ns.ps(srv.name)
      for (var i = 0; i < (srv.process_list.length - 1); i++) {
        srv.active_threads += srv.process_list[i].threads
      }
    }
  };

  update_servers();
  ns.tprint(script_servers);
  ns.tprint(targetServer);
  // Script-part (in loop)
  const gname = "/ctrl/grow_server.script";
  const wname = "/ctrl/weaken_server.script";
  while (1) {
    targetServer.map(tserv => {
      const cur_mon = ns.getServerMoneyAvailable(tserv);
      const max_mon = ns.getServerMaxMoney(tserv);
      const g_multi = Math.ceil(max_mon / cur_mon);
      const ng_threads = Math.ceil(ns.growthAnalyze(tserv, g_multi));
      if (cur_mon <= (max_mon * 0.99)) { // grow with enough threads for MaxMoney on the Server
        for (i = 0; i == 1; null) {
          for (const ssrv_key in script_servers) {
            const ssrv = script_servers[ssrv_key];
            const cgprocs = ssrv.process_list.filter(gpro => gname.indexOf(gpro.filename) != null);
            const sgthreads = script_servers.process_list.filter(gpro => gpro.filename.includes(gname) && gpro.args.includes(tserv)).threads.reduce((a,b) => a+b);
            if (ng_threads > 0 && ng_threads - sgthreads > 0 && !cgprocs.args.includes(tserv)) {
              if (ssrv.free_threads > g_threads) {
                ns.exec(gname, ssrv, g_threads, tserv);
                ng_threads = 0;
                update_servers;
                i = 1
              }
              else if (ssrv.free_threads > 1 && ssrv.free_threads < g_threads) {
                ns.exec(gname, ssrv, ssrv.free_threads, tserv);
                ng_threads -= ssrv.free_threads;
                update_servers()
              }
              else {
                if (ng_threads == 0) { i = 1 } // exit because there are enough grow running
                else { ns.tprint("GWCTRL: How?") }
              }
            }
            else if (ngthreads == 0) {
              i=1
            }
            else {
              ns.tprint("GWCTRL: Server"+ssrv.name+ "not free to grow " + tserv + " . Waiting 5 secs");
              await ns.sleep(5000);
              update_servers()
            }
          }
        }
      }
      else { // server reached 99% of MaxMoney else weaken with enough threads for HackCTRL
        const nwthreads = Math.ceil((ns.getServerSecurityLevel(host) - ns.getServerMinSecurityLevel(host)) / 0.05);
        for (i = 0; i == 1; null) {
          for (const ssrv_key in script_servers) {
            const ssrv = script_servers[ssrv_key];
            const cwprocs = ssrv.process_list.filter(wpro => wpro.filename.includes(wname));
            const swthreads = script_servers.process_list.filter(wpro => wpro.filename.includes(wname) && wpro.args.includes(tserv)).threads.reduce((a,b) => a+b);
            if (nwthreads > 0 && nwthreads - swthreads > 0 && !cwprocs.args.includes(tserv)) {
              if (ssrv.free_threads > nwthreads) {
                ns.exec(wname, ssrv, nwthreads, tserv);
                nwthreads = 0;
                update_servers();
                i = 1
              }
              else if (ssrv.free_threads > 1 && ssrv.free_threads < nwthreads) {
                ns.exec(wname, ssrv, ssrv.free_threads, tserv);
                nwthreads -= ssrv.free_threads;
                update_servers()
              }
              else {
                if (nwthreads == 0) { i = 1 } // exit because there are enough grow running
                else { ns.tprint("GWCTRL: Again?") }
              }
            }
            else if (nwthreads == 0) {
              i=1
            }
            else {
              ns.tprint("GWCTRL: Server"+ssrv.name+"not free to weaken " + tserv + " . Waiting 5 secs");
              await ns.sleep(5000);
              update_servers()
            }
          }
        }
      }
    });
    ns.sleep(10000)
  }
}